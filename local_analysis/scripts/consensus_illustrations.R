## Visualises a subset of locally aligned consensuses (Figure 3-9)

library(tidyverse)
library(raster)

## Takes consensus sequence and converts to a vector of lines
## Where each line is wrapped at the specified line length
## And there is an empty string after each line of sequence
convert_consensus_to_sequence_list <- function(consensus, line_length) {
    sequences <- NULL
    full_rows <- nchar(consensus) %/% line_length
    if (full_rows > 0) {
        for (i in 1:full_rows) {
            start <- (i-1)*line_length + 1
            stop  <- i*line_length
            line <- substr(consensus, start, stop)
            sequences <- c(sequences, line, "")
        }
    }
    start <- full_rows*line_length + 1
    stop  <- nchar(consensus)
    line <- substr(consensus, start, stop)
    sequences <- c(sequences, line, "")
    
    return(sequences)
}

## Takes sequence vector from previous function and converts to annotations dataframe
## Specifies X and Y coordinates (corresponding to tiles generated by raster::raster())
## for each base, and each numerical annotation underneath
convert_sequences_to_annotations <- function(sequences, line_length, interval = 5) {
    x_interval <- 1 / line_length
    y_interval <- 1 / length(sequences)
    
    data <- data.frame(NULL)
    
    i_values_to_ignore <- 0
    for (i in 1:length(sequences)) {
        ## Don't count blank/spacer rows when adding up numbers
        if (sequences[i] == "") {
            i_values_to_ignore <- i_values_to_ignore + 1
        }
        
        if (sequences[i] != "") {
            for (j in 1:nchar(sequences[i])) {
                ## Annotate actual sequence
                x_position <- x_interval * j - x_interval/2
                y_position <- 1 - (y_interval * i - y_interval/2)
                annotation <- substr(sequences[i], j, j)
                type <- "Sequence"
                data <- rbind(data, c(x_position, y_position, annotation, type))
                
                ## Annotate numbers every <interval> bases
                if (j %% interval == 0) {
                    x_position <- x_interval * j - x_interval/2
                    y_position <- 1 - (y_interval * (i+1) - y_interval*2/3)
                    annotation <- as.character((i-1-i_values_to_ignore)*line_length + j)
                    type <- "Number"
                    data <- rbind(data, c(x_position, y_position, annotation, type))
                }
            }
        }
    }
    colnames(data) <- c("x_position", "y_position", "annotation", "type")
    data$x_position <- as.numeric(data$x_position)
    data$y_position <- as.numeric(data$y_position)
    return(data)
}


## A = 1, C = 2, G = 3, T = 4, blank = 0
convert_base_to_number <- function(base) {
    if (base == "A") {
        number <- 1
    } else if (base == "C") {
        number <- 2
    } else if (base == "G") {
        number <- 3
    } else if (base == "T") {
        number <- 4
    } else {
        print("Error: base must be A/T/C/G")
    }
    return(number)
}

## Converts sequence to numbers using the 
convert_sequence_to_numbers <- function(sequence, length) {
    numerical_vector <- NULL
    for (i in 1:length) {
        if (i <= nchar(sequence)) {
            numerical_vector[i] <- convert_base_to_number(substr(sequence, i, i))
        } else {
            numerical_vector[i] <- 0
        }
    }
    return(numerical_vector)
}

## Plots the image from the sequence vector
plot_image_tile <- function(sequences, colour_values) {
    max_length <- max(nchar(sequences))
    image_matrix <- matrix(NA, nrow = length(sequences), ncol = max_length)
    for (i in 1:length(sequences)) {
        numeric_sequence_representation <- convert_sequence_to_numbers(sequences[i], max_length)
        image_matrix[i, ] <- numeric_sequence_representation
    }
    image_data <- as.data.frame(raster(image_matrix), xy = TRUE)
    
    plot <- ggplot(image_data, aes(x = x, y = y, fill = as.character(layer))) +
        geom_tile() +
        scale_fill_manual(values = colour_values) +
        guides(x = "none", y = "none", fill = "none") +
        theme(axis.title = element_blank(), plot.margin = grid::unit(c(0.5, 0.5, 0, 0.5), "inches")) +
        scale_x_continuous(expand = c(0, 0)) +
        scale_y_continuous(expand = c(0, 0))
    
    return(plot)
}


## Adds the annotations and saves the image
generate_consensus_image <- function(consensus_sequence, colour_values = c("0" = "white", "1" = "#FFAA00", "2" = "#00BC00", "3" = "#0000DC", "4" = "#FF1E1E"),
                                     line_wrapping = 75, number_interval = 15, return = TRUE, save = FALSE, filename = "image.png", pixels_per_base = 100) {
    sequences <- convert_consensus_to_sequence_list(consensus_sequence, line_wrapping)
    if (max(nchar(sequences)) < line_wrapping) {line_wrapping <- max(nchar(sequences))}
    annotations <- convert_sequences_to_annotations(sequences, line_wrapping, number_interval) 
    
    result <- plot_image_tile(sequences, colour_values) +    
        geom_text(data = annotations, aes(x = x_position, y = y_position, label = annotation, col = type, size = type), inherit.aes = F) +
        scale_colour_manual(values = c("Number" = "darkred", "Sequence" = "white")) +
        scale_discrete_manual("size", values = c("Number" = 12.5, "Sequence" = 15)) +
        guides(col = "none", size = "none")
    
    if (save == TRUE) {
        ggsave(filename, plot = result, dpi = pixels_per_base, width = max(nchar(sequences))+1, height = length(sequences)+0.5, limitsize = FALSE)    
    }
    
    if (return == TRUE) {
        return(result)
    }
}



colour_values <- c("0" = "white", "1" = "#FFAA00", "2" = "#00BC00", "3" = "#0000DC", "4" = "#FF1E1E")


consensuses <- read.csv("intermediate_files/consensus_read_data_combined.csv") %>%
    filter(type == "Consensus", method == "Local")


## Create FASTA of all local consensuses
consensuses_for_fasta <- consensuses %>%
    arrange(publication_id, desc(allele))
fasta_consensus_output <- rep(NA, 76)
for (i in 1:38) {
    fasta_consensus_output[i*2 - 1] <- paste0(">", consensuses_for_fasta[i, "publication_id"], " ", consensuses_for_fasta[i, "allele"])
    fasta_consensus_output[i*2] <- consensuses_for_fasta[i, "sequence"]
}
writeLines(fasta_consensus_output, "intermediate_files/all_local_consensuses.fasta")



root = "output_figures/Figure 3-8 - Selected consensus visualisations - "

## NIID:
f1_iii_3_short <- consensuses %>% filter(publication_id == "F1-III-3", allele == "Short") %>% pull(sequence)
generate_consensus_image(f1_iii_3_short, filename = paste0(root, "F1-III-3_short.png"), colour_values, line_wrapping = 75, number_interval = 15, return = TRUE, save = TRUE)

f1_iii_3_long <- consensuses %>% filter(publication_id == "F1-III-3", allele == "Long") %>% pull(sequence)
generate_consensus_image(f1_iii_3_long, filename = paste0(root, "F1-III-3_long.png"), colour_values, line_wrapping = 75, number_interval = 15, return = TRUE, save = TRUE)


podar_2023_long <- consensuses %>% filter(publication_id == "Podar 2023", allele == "Long") %>% pull(sequence)
generate_consensus_image(podar_2023_long, filename = paste0(root, "Podar_2023_long.png"), colour_values, line_wrapping = 75, number_interval = 15, return = TRUE, save = TRUE)

podar_2023_short <- consensuses %>% filter(publication_id == "Podar 2023", allele == "Short") %>% pull(sequence)
generate_consensus_image(podar_2023_short, filename = paste0(root, "Podar_2023_short.png"), colour_values, line_wrapping = 75, number_interval = 15, return = TRUE, save = TRUE)


## OPDM:
f2_ii_2_short <- consensuses %>% filter(publication_id == "F2-II-2", allele == "Short") %>% pull(sequence)
generate_consensus_image(f2_ii_2_short, filename = paste0(root, "F2-II-2_short.png"), colour_values, line_wrapping = 75, number_interval = 15, return = TRUE, save = TRUE)

f2_ii_2_long <- consensuses %>% filter(publication_id == "F2-II-2", allele == "Long") %>% pull(sequence)
generate_consensus_image(f2_ii_2_long, filename = paste0(root, "F2-II-2_long.png"), colour_values, line_wrapping = 75, number_interval = 15, return = TRUE, save = TRUE)


f2_i_1_short <- consensuses %>% filter(publication_id == "F2-I-1", allele == "Short") %>% pull(sequence)
generate_consensus_image(f2_i_1_short, filename = paste0(root, "F2-I-1_short.png"), colour_values, line_wrapping = 75, number_interval = 15, return = TRUE, save = TRUE)

f2_i_1_hyper <- consensuses %>% filter(publication_id == "F2-I-1", allele == "Hyper") %>% pull(sequence)
generate_consensus_image(f2_i_1_hyper, filename = paste0(root, "F2-I-1_hyper.png"), colour_values, line_wrapping = 75, number_interval = 15, return = TRUE, save = TRUE)



## MND:
mnd1_short <- consensuses %>% filter(publication_id == "MND1", allele == "Short") %>% pull(sequence)
generate_consensus_image(mnd1_short, filename = paste0(root, "MND1_short.png"), colour_values, line_wrapping = 75, number_interval = 15, return = TRUE, save = TRUE)

mnd2_short <- consensuses %>% filter(publication_id == "MND2", allele == "Short") %>% pull(sequence)
generate_consensus_image(mnd2_short, filename = paste0(root, "MND2_short.png"), colour_values, line_wrapping = 75, number_interval = 15, return = TRUE, save = TRUE)

mnd7_short <- consensuses %>% filter(publication_id == "MND7", allele == "Short") %>% pull(sequence)
generate_consensus_image(mnd7_short, filename = paste0(root, "MND7_short.png"), colour_values, line_wrapping = 75, number_interval = 15, return = TRUE, save = TRUE)
